
字符串是一个或多个字符的序列。

---
## 01 char类型数组和null字符
C语言没有专门用于储存字符串的变量类型，字符串都被存储在[[03 - 2 常量#^cf640e|char类型]]的**数组**中，数组由连续的**存储单元**（通常是 1 字节）组成，字符串中的字符被存储在相邻的存储单元中，**每个单元存储一个字符**。
![02 - 0 - 1.png](/引用文件/02%20-%200%20-%201.png)

### （1）空字符 null
空字符，[[03 - 2 常量#^fbd6bc|转义字符]]为 \0，C语言用它来**标记字符串的结束**。
空字符不是数字0，它是**非打印字符**，其ASCII码值是（或等价于）0。
>[!warning]
>C中的字符串一定以一个空字符结束，**空字符不是空格**，这意味着数组的容量必须至少比待存储字符串中的字符多1 。

>[!success]
>不用亲自把空字符放入字符串末尾，编译器会在末尾加上空字符。
### （2）数组
数组是**同类型数据元素的有序序列**。
```c
char name[40];
```
该语句声明了一个包含40个储存单元的数组，每个单元储存一个char类型的值。
name后面的方括号表示这是一个数组，方括号中的40表明该数组中的元素数量。
>[!tip]
>声明一个变量和一个数组的区别：
>
>![02 - 0 - 2.png](/引用文件/02%20-%200%20-%202.png)
>![02 - 0 - 3.png](/引用文件/02%20-%200%20-%203.png)
>
>字符和字符串的区别：
>
>![02 - 0 - 4.png](/引用文件/02%20-%200%20-%204.png)

## 02 strlen()函数和sizeof运算符
### （1）sizeof运算符
sizeof是C语言内置运算符，**以字节为单位**给出**当前系统指定类型**的大小。
```c 
int a = 100;
printf("this type has %zd bytes.",sizeof(a);
printf("this type has %zd bytes.",sizeof(int));
printf("this type has %zd bytes.",sizeof(float));
```
**size_t类型**：C语言规定，sizeof返回size_t类型的值。这是一个无符号整数类型，但不是新类型，是unsigned int或unsigned long的别名。

>[!warning]
>若是变量，sizeof后可加括号，也可不加。若是数据类型，sizeof后必须加括号。

>[!tip]
>一些不支持C99和C11的编译器可以使用"%u"或"%lu"代替"%zd"。
### （2）strlen()函数
strlen()函数可以给出字符串中字符的长度。
ANSI C（C89/C90）必须移除：
```c
#include <string.h>
```

```c
#include <stdio.h>
#include <string.h>
#define NAME Xiaomi HyperOS
int main()
{
	char name[20];
	scanf("%s",name);
	printf("%zd",strlen(name));
	printf("%zd",strlen(NAME));
	
	return 0;
}
```
string.h头文件包含多个与字符串相关的函数原型，包括string()。
>[!warning]
>strlen()函数不会将字符串用于标记结束的\0计入。但是**遇到\0结束计数**。

## 03 处理字符串的函数 <string.h>
### （1）输入输出字符串的函数——gets和puts函数
```c
char str[]={"China\nBeijing"};
puts(str);
return 0;
```
**puts(字符数组名)**的作用是输出一个字符串到终端。同时会输出**控制字符（如换行符）**。
```c
char str[10]; //使用gets函数输入数组，一定要给出数组长度。
gets(str);
printf("%s",str);
```
**gets(字符数组名)**的作用是从终端输入一个**字符串**到字符数组，并且得到一个函数值。
该函数值是**字符数组的起始地址**。

此外，要注意gets函数**会自动丢弃输入末尾的换行符**。

>[!important]
>用puts和gets函数只能输入和输出**一个**字符串。

>[!warning]
>gets极其危险，已从C标准中**废除**。它**不检查缓冲区边界**，会导致**缓冲区溢出**，是严重的安全漏洞来源。
>此外，使用scanf函数读取字符串同样**不检查缓冲区边界**。可以使用scanf_s

### 更安全的选择 - fgets函数
```c
char ch[10];
fgets(ch, sizeof(ch), stdin);
```
ch是**字符数组名**，后面是**缓冲区长度参数**，最后是**指定输入流**，stdin表示从键盘输入。

fgets函数最多存入sizeof - 1个字符，**自动加\0**。

fgets会将输入中的**换行符\n一并存入缓冲区**，便于判断输入是否完整，后续可通过**字符串处理函数**移除换行符。

与gets区别：
![02 - 0 - 5](/引用文件/02%20-%200%20-%205.png)

### 更安全的选择 - scanf_s函数
```c
scanf_s("%c%c", &a, 1, &b, 1); //1即为限制读取缓冲区长度为1个字符。
```
scanf_s 是**微软专属的 scanf 安全增强版**，**强制指定缓冲区大小**以防御内存越界，**未纳入 ANSI C 标准**，仅支持 Visual Studio 系列编译器，跨平台兼容性受限。


### （2）字符串连接函数——strcat函数
其一般形式为**strcat(字符数组1, 字符数组2)**

其作用是把两个字符数组中的字符串连接起来，把字符串2接到字符串1后面，**结果放在字符数组1中**。

函数调用后会得到一个函数数值——**字符数组1的地址**。
```c
#include <stdio.h>
#include <string.h>
int main()
{
	char str1[]={"Xiaomi "};
	char str2[]={"HyperOS 3"}; 
	strcat(str1,str2);
	printf("%s",str1);
	
	return 0;
 } 
 ```

>[!warning]
>字符数组1必须足够大，以便容纳连接后的新字符串。否则会导致**缓冲区溢出**。

>[!note]
>连接前两个字符串的后面都有′\0′，连接时将字符串1后面的′\0′取消，只在新串最后保留′\0′。

### （3）字符串复制函数——strcpy函数
```c
char str1[]="Xiaomi HyperOS 3";
char str2[]="Xiaomi HyperCore";
strcpy(str1, str2);
//or
char str[]="Xiaomi SU7"
str(str1, "Xiaomi YU7");
```
作用：将字符串2复制到字符数组1中去。
>[!important]
>+ （1）“字符数组1”必须写成**数组名**形式，“字符串2”可以是**字符数组名**，也可以是一个**字符串常量**。
>+ （2）字符串1必须**足够长**以容纳字符串2。
>+ （3）若在复制前未对字符数组1初始化或赋值，则其各字节中的内容**无法预知**，复制时将字符串2和其后的′\0′一起复制到字符数组1中，**取代字符数组1中前面的字符**，未被取代的字符**保持原有内容**。

>[!caution]
>不能直接将字符串赋值给数组，数组名只是一个地址！
>![02 - 0 - 6](/引用文件/02%20-%200%20-%206.png)

### 复制前n个字符——strncpy函数
```c
char str1[10]="Xiaomi";
char str2[10]="HyperOS";
strncpy(str1, str2, 3);
```
strncpy函数的作用是将str2中的前n个字符复制到str1中，**末尾仍保留\0**。

### （4）字符串比较函数——strcmp函数
```c
strcmp("Xiaomi", "HUAWEI");
strcmp(str1, str2);
strcmp(str1, "HUAWEI");
```
作用：比较字符串1和字符串2。

规则是：将两个字符串**自左至右逐个字符**相比(按**ASCII码值**大小比较)，直到出现**不同的字符或遇到′\0′为止**。

比较结果：
+ 如果字符串1与字符串2相同，则函数值为0。
+ 如果字符串1>字符串2，则函数值为一个**正整数 1**。
+ 如果字符串1<字符串2，则函数值为一个**负整数 -1**。

### （5）字符串长度测量函数——strlen函数
上文已提到。

### （6）字符串转换大小写函数——strlwr函数和strupr函数
strlwr(字符串或数组名) 将**大写转换为小写**。
strupr(字符串或数组名) 将**小写转换为大写**。
