
scanf函数的基本结构是scanf(格式控制，地址表列);
scanf()函数与printf()函数正好相反，printf()函数将整形、浮点型等转换为字符串显示在屏幕上的文本，而scanf函数将用户输入的文本转换为整形、浮点型、字符串等类型。

---
## 00 概念
**转换说明**：

![转换说明](/引用文件/02%20-%202%20-%202.png)

**修饰符**：

![02 - 2 - 3.png](/引用文件/02%20-%202%20-%203.png)
![02 - 2 - 4.png](/引用文件/02%20-%202%20-%204.png)

---
## 01 读取整数 "%d"
```c
scanf("%d",&price);
```
 即scanf这个函数读入下一个==**整数**==，读到的结果赋值给变量price。
 ```c
 int a = 0,b = 0;
 scanf("%d %d",&a,&b);
 printf("%d %d",a,b);
 ```
#### 多变量读取
![02 - 2 - 1.png](/引用文件/02%20-%202%20-%201.png)

scanf函数读取用户输入内容时，要规范用户输入格式，具体如上。

==若用户未按照规定格式输入，则会出错==。

读取到的数据，会依次赋值给后面的变量。
```c
int a = 0,b = 0;
scanf("price%d %d",&a,&b);
printf("%d %d",a,b);
```
此时，用户需输入：price23 45

>[!note]
>##### 补充：缓冲区概念
>在一个C语言程序中存在一个缓冲区，用户的输入都会存在缓冲区中。（包括空格和回车等）

>[!note]
>##### 补充：最后%d后空格问题
>若连续读取多个变量，最后一个%d后若有空格，在读取最后一个数字后并不会结束程序，而当用户输入一个非空字符时，程序才结束。
>这是因为：在scanf中，空格代表忽略用户输入的**任意数量的空白字符**（包括多个空格、Tab、回车），且%d前也会默认忽略上述。因此，在读取完最后一个整数后，scanf遇到空格，程序会进入忽略用户输入的空白字符状态，直到遇到非空>字符。

## 02 读取浮点数 "%f"或"%lf"
区分输出浮点数[[02 - 1 printf() 函数#==03 输出浮点数 "%f"==|"%f"]]，scanf函数将%f视作float类型，%lf则升格为double类型，具体修饰符作用如上图。
```c
double foot;
double inch;
scanf("%lf %lf",&foot,&inch);
printf("%f %f",foot,inch);
```

## 03 读取字符串 "%s"
```c
#include <stdio.h>
int main()
{
	char name[40];
	printf("What is your name?");
	scanf("%s",name);
	printf("Hello,%s",name);
	
	return 0;
}
```
一般而言，scanf()函数只会读取字符串中的一个单词，在读到空白（换行符，制表符和空格）就停止了，不会读取一整句。
>[!warning]
>注意：将**字符读入字符数组**时，变量名前==**不能加&**==。

>[!note]
>若使用字段宽度，scanf会在字段结尾或第1个空白字符处停止读取（满足两个条件之一即停止）。

>[!note]
>scanf()函数将字符串放入指定数组中时，它会在字符序列的末尾加上“\0”，让数组中的内容组成一个字符串。

## 04 读取字符 "%c"
```c
char a;
scanf("%c",&a);
```
唯一例外的是%c转换说明，根据%c，scanf会读取==**每个字符（包括换行符、制表符、空格）**==。

>[!warning]
>使用%c时，变量前==**要加&**==

---

## 注意事项
scanf用==**空白（换行符，指标符，空格）**==将输入分为多个字段，在依次将转换说明和字段匹配时跳过空白。

#### （1）缓冲区
执行程序时，用户数据的内容都会存放进一个缓冲区中。
**缓冲区**是程序在内存中预留的一块区域，用来临时存放数据。
##### 缓冲区的工作原理
缓冲区就像一个 "中转站"：
- 数据先写入缓冲区（批量写入）
- 当缓冲区满或特定条件触发时，再一次性处理这些数据
这样可以减少实际 I/O 操作次数，大幅提高性能。
##### C语言中的缓冲区类型
（1）全缓冲：缓冲区满时才进行实际 I/O（如磁盘文件）
（2）行缓冲：遇到换行符或缓冲区满时进行 I/O（如终端输出）
（3）无缓冲：数据立即进行 I/O（如标准错误输出 stderr）

因此在终端中运行的程序，属于**行缓冲**类型，遇到换行符或缓冲区满时进行I/O

>[!note]
>```c
>#include <stdio.h>
>int main()
>{
>    char a,name[40];
>    scanf("%s",name);
>    scanf("%c",&a);
>    printf("%s%c",name,a);
>    return 0;
>}
>```
>最后输出的结果是
>```c
>xiaomi
>
>```

原理是：scanf()会读取缓冲区中内容，当第一次读取结束后，会紧接着进行第二次读取。由于第一次用户需输入回车来提交缓冲区中的内容供给scanf第一次读取，第一个scanf读到回车（\n）将其放回缓冲区，第二个scanf紧接着读取，由于%c读取任何内容，因此第二个scanf读到\n并赋给a。

>[!note]
>若第二次读取时缓冲区中的内容scanf需要跳过至缓冲区为空时，则需要用户继续输入。

#### （2）格式字符中的普通字符
格式字符串中的**空格**意味着**跳过==下一个输入项==前的所有空白**。
除了%c，其他转换说明都会自动跳过待输入值前的所有空白。
```c
scanf("%d,%d",&a,&b);
```
则可以输入
```c
34,46
34,   45
  34,45
  34,    45
```
当,前有空格
```c
scanf("%d ,%d");
```
则可输入
```c
34,56
34    ,56
34    ,   56
...
```

>[!note]
>**对于%c，前有空格作用不变，依旧自动跳过下一个输入项前的所有空白**
>```c
>scanf("%c",&ch);
>```
>从输入的第一个字符开始读取。
>```c
>scanf(" %c",&ch);
>```
>从输入的第一个非空字符开始读取。

#### （3）scanf（）的返回值
scanf的返回值是**成功读取的项数**
以下假设均正确读取：
```c
num = scanf("%d", &a);     //num = 1
num = scanf("%d%d", &b);   //num = 2
```



