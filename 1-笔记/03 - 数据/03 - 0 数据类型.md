# 03 - 0 数据类型

![03 - 0 - 1.png](/引用文件/03%20-%200%20-%201.png)

## 01 整型类型
![03 - 0 - 2.png](/引用文件/03%20-%200%20-%202.png)

## 02 浮点类型
![03 - 0 - 3.png](/引用文件/03%20-%200%20-%203.png)

### 浮点数的比较
浮点数不能直接比较大小，应使用fabs函数，与某一精度比较。
例如：
```c
#include <stdio.h>
int main()
{
	double x=0.1, y=0.2;
	if(x+y == 0.3)
		printf("Yes!");
	else 
		printf("No!");
	
	return 0;
}
```
最终输出：``No!``

## 03 布尔类型 __Bool类型

表示真或假的变量被称为布尔变量。==**布尔类型的变量只能存储 1（真）或 0（假）**==。如果把其他类型的变量数值赋值给_Bool类型的变量，该变量会被设置为1。

---

## 注意事项
### （1）赋值越界问题
#### 给无符号整数越界赋值
现象：**回绕（Wrap-Around）或模运算（Modulo Operation）**
当一个值超出了无符号整数的表示范围时，它会自动对其表示范围的大小**取模**。也就是说，它会像一个循环的表盘一样，**超过最大值后会从最小值重新开始**。
例如：
```c
char c = 291;
printf("%d", c);
```
这种情况下会输出：**291%256=35**

#### 给有符号整数越界赋值
现象：**未定义行为**
**回绕（Wrap-Around）：**和无符号整数类似，但通常是按照二进制补码的规则。例如，int 的最大值是 2147483647，加 1 后可能会变成 -2147483648。
**饱和（Saturation）：**将值 “夹紧” 在最大值或最小值。例如，超出最大值就取最大值，低于最小值就取最小值。（这种情况在 DSP 或特定硬件相关的编译器中较常见，但不是标准行为）。
**程序崩溃：**可能导致程序异常终止。
**产生垃圾值：**变量可能得到一个完全意想不到的值。
**编译器优化**：现代编译器在优化时会假设程序不会出现未定义行为。如果你写出了依赖于有符号整数溢出的代码，编译器可能会优化掉你的逻辑，导致结果完全错误。

#### 给浮点数越界赋值
现象：结果为**无穷大（Infinity）**或**非数值（NaN）**
**溢出到无穷大：**当你给一个浮点数赋一个超出其最大可表示范围（FLT_MAX 或 DBL_MAX）的正值时，结果会是 +infinity。赋值一个超出其最小可表示范围（-FLT_MAX 或 -DBL_MAX）的负值时，结果会是 -infinity。
**下溢到零：**当你给一个浮点数赋一个**非常接近于零，但又大于零的最小值**时，它可能会被表示为 0.0。
**非数值（NaN）：**当运算的结果不是一个有效的实数或无穷大时，会产生 NaN（Not a Number）。例如，sqrt(-1.0) 或 0.0 / 0.0。直接赋值一个导致 NaN 的值比较少见，但运算可能产生。
例如：
```c
#include <stdio.h>
#include <float.h> // 包含 FLT_MAX 等定义

int main() {
    float f;
    double d;

    // 赋值一个远大于 FLT_MAX 的数
    f = FLT_MAX * 2.0f;
    printf("f = %f\n", f); // 输出：f = inf 或 1.#INF00 (表示正无穷)
    // 赋值一个远小于 -FLT_MAX 的数
    f = -FLT_MAX * 2.0f;
    printf("f = %f\n", f); // 输出：f = -inf 或 -1.#INF00 (表示负无穷)
    // 一个会产生 NaN 的运算
    d = 0.0 / 0.0;
    printf("d = %lf\n", d); // 输出：d = nan 或 1.#QNAN0 (表示非数值)
    
    return 0;
}
```
