C允许函数调用它自己，这种调用过程称为**递归**。

---

## 01 递归程序示例
```c
#include <stdio.h>

void up_and_down(int);

int main()
{
    up_and_down(1);
    return 0;
}

void up_and_down(int n)
{
    printf("Level %d\n", n);
    if(n<4)
        up_and_down(n+1);
    printf("Level %d\n", n);
}
```
运行结果：
```c
Level 1
Level 2
Level 3
Level 4
Level 4
Level 3
Level 2
Level 1

```
该程序中，主调函数第一次函数调用时进入**第1级递归**，然后函数自己调用自己，进入**第2级递归**，以此类推。

>[!tip]
>可以假设有一条函数调用链——fun1()调用了fun2()，fun2()调用了fun3()，fun3()调用了fun4，fun4()返回至fun3()，fun3()继续执行结束，返回至fun2()，fun2()继续执行至结束，返回至fun1()，fun1()继续执行至结束，函数调用结束，无返回值。

## 02 递归的基本原理
#### （1）每级函数调用都有自己的变量
每级函数调用，程序都会创建一个变量，它们名字相同，但值不相同，并不冲突。

![08 - 2 - 1](/引用文件/08%20-%202%20-%201.png)

#### （2）每次函数调用都会返回一次
当函数执行完毕后，控制权将被传回**上一级递归**，程序必须按顺序**逐级返回递归**。不能跳级返回main函数中的第一级调用。

#### （3）语句运行顺序
+ 递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如上面的程序依次打印Level 1、2、3、4。
+ 递归函数中位于递归之后的语句，均按被调函数相反的顺序执行。例如上面的程序后面依次打印Level 3、2、1。

>[!warning]
>+ 虽然每级递归都有自己的变量，但并没有拷贝函数的代码。
>+ 递归函数必须包含能让递归调用停止的语句。

## 03 尾递归
将函数的递归调用放在函数的末尾（即return语句之前），这种形式的递归叫做**尾递归**。
因为递归调用放在函数的末尾，是最简单的递归形式，某种程度上相当于循环。
```c
//使用递归计算阶乘。
#include <stdio.h>
int jiecheng(int n);
int main()
{
    int n;
    scanf("%d", &n);
    if(n==0) printf("0");
    else if(n<0) printf("Error!");
    else printf("%d", jiecheng(n));
    return 0;
}
int jiecheng(int n)
{
    int result=1;
    if(n>1)
        reuslt = n * jiecheng(n--);
    return result;
}
```
#### （1）递归与倒序运算
递归在处理**倒序问题**时非常方便。例如求二进制的函数：当输入十进制数n，n%2首先得到的是最后一位，而我们希望它最后输出，这是就可以利用尾递归。
```c
#include <stdio.h>
void binary(int n);
int main()
{
    int n;
    scanf("%d", &n);
    binary(n);
    return 0;
}
void binary(int n)
{
    int r;
    r = n%2;
    if(n>=2)
        binary(n/2);
    putchar(r==0 ? '0' : '1');
}
```