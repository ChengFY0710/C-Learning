**指针**是一个值为**内存地址**的变量（或数据对象）。
![09 - 1 - 1](/引用文件/09%20-%201%20-%201.png)

---

## 00 间接运算符 * 和取地址符 &
假设一个指针变量名是ptr，可以编写如下语句：
```c
ptr = &num;
```
对于这条语句我们说**ptr指向num**，ptr和&num的区别是：ptr是**变量**而&num是**常量**。
同时我们还可以把ptr指向别处：
```c
ptr = &fir;
num = *ptr
```
此时，间接运算符的作用是**找出储存在fir变量中的值**。

---

## 01 声明指针变量
注意：声明指针变量时必须指定指针变量所指向变量的类型。
```c
int * pi;     //pi是指向int类型变量的指针。
float * he;
double * fir, * big;
```

>[!tip]
>*和名称之间的空格可有可无，一般在声明变量的时候使用空格，在解引用时不使用空格。

>[!warning]
>在我们的系统中，地址按**字节**编址，例如short类型占用2字节，double类型占用8字节，而**指针变量加一**则表示的是**增加一个存储单元**，对于数组而言，加一后的地址指的是**下一个元素的地址**，而不是下一个字节的地址。这也是声明指针变量时必须声明指针变量所指向的变量类型的原因之一。
>![alt text](/引用文件/09%20-%201%20-%202.png)

### 使用printf打印地址
```c
#include <stdio.h>
int main()
{
	int num[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	int * add = num;
	printf("%p", add);
	
	return 0;
}
```
使用%p转换说明，后面跟上**指针变量名**。输出的结果即地址**一般使用16进制数**表示的。

## 02 指针操作
### （1）赋值
可以把地址赋值给指针。例如可以用数组名、带地址运算符&的变量名、另一个指针赋值给另一个指针。
```c
int * ptr;
int num[10]={0};
ptr = num;
```
>[!warning]
>地址所对应的数据类型应和指针变量所指向的变量类型对应。C99和C11已经强制不允许这样做。

### （2）解引用
*解引用运算符给出了指针指向地址上存储的值。

### （3）取址
和所有变量一样，指针变量也有自己的地址和值。使用&地址运算符同样可以获得指针变量的地址。

### （4）指针与整数相加 / 减
在这种情况下，指针会与它所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。

### （5）递增/减指针
递增指向数组元素的指针可以让该指针移动至**数组的下一个元素**。

### （6）指针求差
可以计算两个指针的差值。通常，求差的两个指针分别指向**同一个数组的**不同元素，通过计算求出两元素间的距离。
注意⚠️：差值的单位与**数组类型的单位相同**，例如``ptr3 - ptr1 == 2``，意思是这两个指针所指向的两个元素**相隔两个int**，而不是2字节。
>[!warning]
>只要保证两个指针指向两个相同的数组（或者其中一个指针指向数组后面的第一个地址），C都能保证相减的结果有效。否则，求差运算可能会得出一个值，或者导致运行错误。

### （7）比较
使用**关系运算符**可以比较两个指针的值，前提是两个指针都指向**两个相同类型的对象**。


