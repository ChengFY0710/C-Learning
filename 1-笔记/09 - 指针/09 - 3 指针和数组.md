## 01 指针和数组
```c
int num[10]={1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
```
此时，num是该数组**第一个元素**的**地址**。因此``num``和``&num[0]``所表示的都是num数组中**第一个元素**在内存中存放的**地址**，且都是**常量**。

因此：
```c
int * add = num;
add == &num[0];
add + 2 == &num[2];
*(add + 2) == num[2];
*(num + 2) == num[2];
```
也就是说，定义num[2]的意思是*(num+2)，到内存num的位置，往后移动两个单元，检索在那里的值。

## 02 形式参数的指针表示法和数组表示法
由于数组的名称是该数组第一个元素的地址，因此可以借助数组来声明指针类型的形式参数。
```c
int func(int * num1, int * num2);
int func(int * , int * );
int func(int num1[], int num2[]);
int fun(int [], int []);
```
由于函数原型中的形参名是假名，可以省略，但是**在函数定义时不能省略**。

### （2）使用数组表示的形式参数
```c
#include <stdio.h>
int suma(int [], int n);
int main()
{
	int num[3]={1, 2, 3};
	int sum;
	sum = suma(num, 3);  //函数调用时输入的是数组名！
	printf("%d", sum);

	return 0;
}
int suma(int ar[], int n)   
{
	int i, sum=0;
	for(i=0; i<n; i++){
		sum += ar[i];     
	}

	return sum;
}
```
函数调用时，向函数提供的实际上是数组第一个元素的地址。但利用数组和指针的特殊关系，可以在函数定义中用 ``ar[i]`` 表示数组中第i+1个元素的值，从这个角度上说，数组是一种特殊的指针。

>[!warning]
>此时，ar 是一个**指针变量**。

### （3）使用指针表示的形式参数
```c
#include <stdio.h>
int suma(int * , int * );
int main()
{
	int num[3]={1, 2, 3};
	int sum;
	sum = suma(num, &num[2]);  //函数调用时输入的是数组名！
	printf("%d", sum);

	return 0;
}
int suma(int * start, int * end)   
{
	int sum=0;
	while(start <= end){
		sum += *start;
		start++;        //注意：指针加一指的是移向下一个指针类型的存储单位
	}

	return sum;
}
```
以上结果和（2）中的结果相同。其中函数循环体可以压缩成一条语句：
```c
sum += *start++;
```

## 03 使用const关键字保护数组/指针
```c
double ar[10]={1.2, 3.4, 5.6};
const double * ptr;
ptr = ar;
```
第二句是指，不能使用ptr指针改变它所指向的值。下列语句：
```c
*ptr++;  //不允许
*ptr = 5.6;  //不允许
ptr++;  //允许，将ptr指向ar[1]
```

>[!warning]
>关于指针赋值和const有一些规则
>+ **已const过指针类型的指针**可以指向**const**和**非const**的数据。
>+ **未const过指针类型的指针**可以指向**非const**数据，但不可指向const数据。

```c
double ar[10]={1, 2, 3, 4, 5};
double * const ptr = ar;
```
此时，就声明了一个**不能指向别处的**指针，此时ptr存储的只能是初始化时的地址。

## 04 指针和多维数组
```c
int zippo[4][2] = { {2,4}, {6,8}, {1,3}, {5, 7} };
```
在这个二维数组中，zippo和zippo[0]都是**数组首元素的地址**，即 **&zippo[0][0]**, 区别是：zippo是占用2个int类型大小的地址，zippo[0]是占用1个int类型大小的地址。因此，递增指针，zippo++ == &zippo[1][0], zippo[0]++ == &zippo[0][1]。

### 重点：解引用多维数组的指针
解引用时，*zippo 只是相当于降了一个维度，其值仍然是**数组首元素的地址**（未递增的情况下）
```c
**zippo == zippo[0][0]
*zippo[0] == zippo[0][0]
```
但也有差别，例如与zippo[2][1]等价的指针表示法是
```c
zippo[2][1] == *(*(zippo + 2) + 1)
```

![09 - 3 - 1](/引用文件/09%20-%203%20-%201.png)

>[!important]
>总结：zippo 和 zippo[0] 的值相等，都表示的是数组首元素（zippo[0][0]）的地址。但是，zippo表示的是**二维数组中首个一维数组的地址**，而zippo[0]表示的是**二维数组中首个一维数组的首元素的地址**，二者**在维度上不同，但值相同**。
>
>![09 - 3 - 2](/引用文件/09%20-%203%20-%202.png)

## 05 声明指向多维数组的指针变量
```c
int zippo[4][2] = {...};
```
由于zippo指向的是数组中首个一维数组的地址，其包含两个int类型的地址，因此需声明一个指针变量，能够指向数组中首个一维数组。声明如下：
```c
int (* ptr)[2]
```
>[!warning]
>[]的优先级高于*，若去掉括号，则如下：
>```c
>int * ptr[2];
>```
>该语句定义了一个数组，数组中的每一个元素都是指向int类型数据的指针。

